{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { expiresAt, looksLikeFetchResponse } from './helpers';\nimport { AuthApiError, AuthRetryableFetchError, AuthUnknownError } from './errors';\n\nconst _getErrorMessage = err => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\n\nconst NETWORK_ERROR_CODES = [502, 503, 504];\n\nasync function handleError(error) {\n  if (!looksLikeFetchResponse(error)) {\n    throw new AuthRetryableFetchError(_getErrorMessage(error), 0);\n  }\n\n  if (NETWORK_ERROR_CODES.includes(error.status)) {\n    // status in 500...599 range - server had an error, request might be retryed.\n    throw new AuthRetryableFetchError(_getErrorMessage(error), error.status);\n  }\n\n  let data;\n\n  try {\n    data = await error.json();\n  } catch (e) {\n    throw new AuthUnknownError(_getErrorMessage(e), e);\n  }\n\n  throw new AuthApiError(_getErrorMessage(data), error.status || 500);\n}\n\nconst _getRequestParams = (method, options, parameters, body) => {\n  const params = {\n    method,\n    headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n  };\n\n  if (method === 'GET') {\n    return params;\n  }\n\n  params.headers = Object.assign({\n    'Content-Type': 'application/json;charset=UTF-8'\n  }, options === null || options === void 0 ? void 0 : options.headers);\n  params.body = JSON.stringify(body);\n  return Object.assign(Object.assign({}, params), parameters);\n};\n\nexport async function _request(fetcher, method, url, options) {\n  var _a;\n\n  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n\n  if (options === null || options === void 0 ? void 0 : options.jwt) {\n    headers['Authorization'] = `Bearer ${options.jwt}`;\n  }\n\n  const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n\n  if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n    qs['redirect_to'] = options.redirectTo;\n  }\n\n  const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';\n  const data = await _handleRequest(fetcher, method, url + queryString, {\n    headers,\n    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson\n  }, {}, options === null || options === void 0 ? void 0 : options.body);\n  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {\n    data: Object.assign({}, data),\n    error: null\n  };\n}\n\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n  const requestParams = _getRequestParams(method, options, parameters, body);\n\n  let result;\n\n  try {\n    result = await fetcher(url, requestParams);\n  } catch (e) {\n    console.error(e); // fetch failed, likely due to a network or CORS error\n\n    throw new AuthRetryableFetchError(_getErrorMessage(e), 0);\n  }\n\n  if (!result.ok) {\n    await handleError(result);\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n    return result;\n  }\n\n  try {\n    return await result.json();\n  } catch (e) {\n    await handleError(e);\n  }\n}\n\nexport function _sessionResponse(data) {\n  var _a;\n\n  let session = null;\n\n  if (hasSession(data)) {\n    session = Object.assign({}, data);\n\n    if (!data.expires_at) {\n      session.expires_at = expiresAt(data.expires_in);\n    }\n  }\n\n  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n  return {\n    data: {\n      session,\n      user\n    },\n    error: null\n  };\n}\nexport function _userResponse(data) {\n  var _a;\n\n  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n  return {\n    data: {\n      user\n    },\n    error: null\n  };\n}\nexport function _ssoResponse(data) {\n  return {\n    data,\n    error: null\n  };\n}\nexport function _generateLinkResponse(data) {\n  const {\n    action_link,\n    email_otp,\n    hashed_token,\n    redirect_to,\n    verification_type\n  } = data,\n        rest = __rest(data, [\"action_link\", \"email_otp\", \"hashed_token\", \"redirect_to\", \"verification_type\"]);\n\n  const properties = {\n    action_link,\n    email_otp,\n    hashed_token,\n    redirect_to,\n    verification_type\n  };\n  const user = Object.assign({}, rest);\n  return {\n    data: {\n      properties,\n      user\n    },\n    error: null\n  };\n}\nexport function _noResolveJsonResponse(data) {\n  return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */\n\nfunction hasSession(data) {\n  return data.access_token && data.refresh_token && data.expires_in;\n}","map":{"version":3,"sources":["../../../src/lib/fetch.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { expiresAt, looksLikeFetchResponse } from './helpers';\nimport { AuthApiError, AuthRetryableFetchError, AuthUnknownError } from './errors';\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [502, 503, 504];\nasync function handleError(error) {\n    if (!looksLikeFetchResponse(error)) {\n        throw new AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    }\n    catch (e) {\n        throw new AuthUnknownError(_getErrorMessage(e), e);\n    }\n    throw new AuthApiError(_getErrorMessage(data), error.status || 500);\n}\nconst _getRequestParams = (method, options, parameters, body) => {\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n    if (method === 'GET') {\n        return params;\n    }\n    params.headers = Object.assign({ 'Content-Type': 'application/json;charset=UTF-8' }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nexport async function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers['Authorization'] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs['redirect_to'] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';\n    const data = await _handleRequest(fetcher, method, url + queryString, { headers, noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, requestParams);\n    }\n    catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    }\n    catch (e) {\n        await handleError(e);\n    }\n}\nexport function _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = expiresAt(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return { data: { session, user }, error: null };\n}\nexport function _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return { data: { user }, error: null };\n}\nexport function _ssoResponse(data) {\n    return { data, error: null };\n}\nexport function _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, [\"action_link\", \"email_otp\", \"hashed_token\", \"redirect_to\", \"verification_type\"]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type,\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user,\n        },\n        error: null,\n    };\n}\nexport function _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */\nfunction hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n}\n//# sourceMappingURL=fetch.js.map"]},"metadata":{},"sourceType":"module"}