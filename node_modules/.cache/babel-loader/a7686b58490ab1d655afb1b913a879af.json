{"ast":null,"code":"import PostgrestFilterBuilder from './PostgrestFilterBuilder';\nexport default class PostgrestQueryBuilder {\n  constructor(url, {\n    headers = {},\n    schema,\n    fetch\n  }) {\n    this.url = url;\n    this.headers = headers;\n    this.schema = schema;\n    this.fetch = fetch;\n  }\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n\n\n  select(columns, {\n    head = false,\n    count\n  } = {}) {\n    const method = head ? 'HEAD' : 'GET'; // Remove whitespaces except when quoted\n\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {\n      if (/\\s/.test(c) && !quoted) {\n        return '';\n      }\n\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n\n      return c;\n    }).join('');\n    this.url.searchParams.set('select', cleanedColumns);\n\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`;\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n\n\n  insert(values, {\n    count,\n    defaultToNull = true\n  } = {}) {\n    const method = 'POST';\n    const prefersHeaders = [];\n\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer']);\n    }\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default');\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   */\n\n\n  upsert(values, {\n    onConflict,\n    ignoreDuplicates = false,\n    count,\n    defaultToNull = true\n  } = {}) {\n    const method = 'POST';\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`];\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer']);\n    }\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default');\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n\n\n  update(values, {\n    count\n  } = {}) {\n    const method = 'PATCH';\n    const prefersHeaders = [];\n\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer']);\n    }\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n\n\n  delete({\n    count\n  } = {}) {\n    const method = 'DELETE';\n    const prefersHeaders = [];\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer']);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/PostgrestQueryBuilder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import PostgrestFilterBuilder from './PostgrestFilterBuilder';\nexport default class PostgrestQueryBuilder {\n    constructor(url, { headers = {}, schema, fetch, }) {\n        this.url = url;\n        this.headers = headers;\n        this.schema = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a SELECT query on the table or view.\n     *\n     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n     *\n     * @param options - Named parameters\n     *\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     *\n     * @param options.count - Count algorithm to use to count rows in the table or view.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    select(columns, { head = false, count, } = {}) {\n        const method = head ? 'HEAD' : 'GET';\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*')\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (count) {\n            this.headers['Prefer'] = `count=${count}`;\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an INSERT into the table or view.\n     *\n     * By default, inserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to insert. Pass an object to insert a single row\n     * or an array to insert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count inserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. Only applies for bulk\n     * inserts.\n     */\n    insert(values, { count, defaultToNull = true, } = {}) {\n        const method = 'POST';\n        const prefersHeaders = [];\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push('missing=default');\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n     * exist, or if it does exist, perform an alternative action depending on\n     * `ignoreDuplicates`.\n     *\n     * By default, upserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to upsert with. Pass an object to upsert a\n     * single row or an array to upsert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n     * duplicate rows are determined. Two rows are duplicates if all the\n     * `onConflict` columns are equal.\n     *\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n     * `false`, duplicate rows are merged with existing rows.\n     *\n     * @param options.count - Count algorithm to use to count upserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. This only applies when\n     * inserting new rows, not when merging with existing rows under\n     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n     */\n    upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true, } = {}) {\n        const method = 'POST';\n        const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`];\n        if (onConflict !== undefined)\n            this.url.searchParams.set('on_conflict', onConflict);\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push('missing=default');\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an UPDATE on the table or view.\n     *\n     * By default, updated rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param values - The values to update with\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count updated rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    update(values, { count, } = {}) {\n        const method = 'PATCH';\n        const prefersHeaders = [];\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform a DELETE on the table or view.\n     *\n     * By default, deleted rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count deleted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    delete({ count, } = {}) {\n        const method = 'DELETE';\n        const prefersHeaders = [];\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (this.headers['Prefer']) {\n            prefersHeaders.unshift(this.headers['Prefer']);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n}\n//# sourceMappingURL=PostgrestQueryBuilder.js.map"]},"metadata":{},"sourceType":"module"}