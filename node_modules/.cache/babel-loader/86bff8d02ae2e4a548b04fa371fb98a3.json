{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\n\nconst noop = () => {};\n\nexport default class RealtimeClient {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint, options) {\n    var _a, _b;\n\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n    const accessToken = (_b = options === null || options === void 0 ? void 0 : options.params) === null || _b === void 0 ? void 0 : _b.apikey;\n    if (accessToken) this.accessToken = accessToken;\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n      this.disconnect();\n      this.connect();\n    }), this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n\n\n  connect() {\n    if (this.conn) {\n      return;\n    }\n\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer';\n\n      this.conn.onopen = () => this._onConnOpen();\n\n      this.conn.onerror = error => this._onConnError(error);\n\n      this.conn.onmessage = event => this._onConnMessage(event);\n\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n\n\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function () {}; // noop\n\n\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n      } else {\n        this.conn.close();\n      }\n\n      this.conn = null; // remove open handles\n\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n    }\n  }\n  /**\n   * Returns all created channels\n   */\n\n\n  getChannels() {\n    return this.channels;\n  }\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n\n\n  removeChannel(channel) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const status = yield channel.unsubscribe();\n\n      if (this.channels.length === 0) {\n        this.disconnect();\n      }\n\n      return status;\n    });\n  }\n  /**\n   * Unsubscribes and removes all channels\n   */\n\n\n  removeAllChannels() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const values_1 = yield Promise.all(this.channels.map(channel => channel.unsubscribe()));\n      this.disconnect();\n      return values_1;\n    });\n  }\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n\n\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Returns the current state of the socket.\n   */\n\n\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\n   * Returns `true` is the connection is open.\n   */\n\n\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n\n  channel(topic, params = {\n    config: {}\n  }) {\n    if (!this.isConnected()) {\n      this.connect();\n    }\n\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n\n\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n\n    let callback = () => {\n      this.encode(data, result => {\n        var _a;\n\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)();\n\n        if (isThrottled) {\n          return 'rate limited';\n        }\n      } else {\n        callback();\n      }\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n\n\n  setAuth(token) {\n    this.accessToken = token;\n    this.channels.forEach(channel => {\n      token && channel.updateJoinPayload({\n        access_token: token\n      });\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, {\n          access_token: token\n        });\n      }\n    });\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n\n\n  _makeRef() {\n    let newRef = this.ref + 1;\n\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n\n    return this.ref.toString();\n  }\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n\n\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n\n\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c._joinRef() !== channel._joinRef());\n  }\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n\n\n  _endPointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /** @internal */\n\n\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n\n      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n        this.pendingHeartbeatRef = null;\n      }\n\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /** @internal */\n\n\n  _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`);\n\n    this._flushSendBuffer();\n\n    this.reconnectTimer.reset();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  /** @internal */\n\n\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n\n    this._triggerChanError();\n\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  /** @internal */\n\n\n  _onConnError(error) {\n    this.log('transport', error.message);\n\n    this._triggerChanError();\n\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  /** @internal */\n\n\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n\n\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  /** @internal */\n\n\n  _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /** @internal */\n\n\n  _sendHeartbeat() {\n    var _a;\n\n    if (!this.isConnected()) {\n      return;\n    }\n\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n      return;\n    }\n\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth(this.accessToken);\n  }\n  /** @internal */\n\n\n  _throttle(callback, eventsPerSecondLimitMs = this.eventsPerSecondLimitMs) {\n    return () => {\n      if (this.inThrottle) return true;\n      callback();\n\n      if (eventsPerSecondLimitMs > 0) {\n        this.inThrottle = true;\n        setTimeout(() => {\n          this.inThrottle = false;\n        }, eventsPerSecondLimitMs);\n      }\n\n      return false;\n    };\n  }\n\n}","map":{"version":3,"sources":["../../src/RealtimeClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE, } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => { };\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     */\n    constructor(endPoint, options) {\n        var _a, _b;\n        this.accessToken = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.headers = DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.transport = w3cwebsocket;\n        this.heartbeatIntervalMs = 30000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.eventsPerSecondLimitMs = 100;\n        this.inThrottle = false;\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.transport)\n            this.transport = options.transport;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n        if (eventsPerSecond)\n            this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n        const accessToken = (_b = options === null || options === void 0 ? void 0 : options.params) === null || _b === void 0 ? void 0 : _b.apikey;\n        if (accessToken)\n            this.accessToken = accessToken;\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs)\n            ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode)\n            ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode)\n            ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n            this.disconnect();\n            this.connect();\n        }), this.reconnectAfterMs);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n        if (this.conn) {\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this._onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.conn) {\n            this.conn.onclose = function () { }; // noop\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this.conn = null;\n            // remove open handles\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.reconnectTimer.reset();\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    removeChannel(channel) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const status = yield channel.unsubscribe();\n            if (this.channels.length === 0) {\n                this.disconnect();\n            }\n            return status;\n        });\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    removeAllChannels() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values_1 = yield Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n            this.disconnect();\n            return values_1;\n        });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    channel(topic, params = { config: {} }) {\n        if (!this.isConnected()) {\n            this.connect();\n        }\n        const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        let callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n                const isThrottled = this._throttle(callback)();\n                if (isThrottled) {\n                    return 'rate limited';\n                }\n            }\n            else {\n                callback();\n            }\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n    setAuth(token) {\n        this.accessToken = token;\n        this.channels.forEach((channel) => {\n            token && channel.updateJoinPayload({ access_token: token });\n            if (channel.joinedOnce && channel._isJoined()) {\n                channel._push(CHANNEL_EVENTS.access_token, { access_token: token });\n            }\n        });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n    _endPointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if ((ref && ref === this.pendingHeartbeatRef) ||\n                event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /** @internal */\n    _onConnOpen() {\n        this.log('transport', `connected to ${this._endPointURL()}`);\n        this._flushSendBuffer();\n        this.reconnectTimer.reset();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    /** @internal */\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    /** @internal */\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    /** @internal */\n    _flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /** @internal */\n    _sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.setAuth(this.accessToken);\n    }\n    /** @internal */\n    _throttle(callback, eventsPerSecondLimitMs = this.eventsPerSecondLimitMs) {\n        return () => {\n            if (this.inThrottle)\n                return true;\n            callback();\n            if (eventsPerSecondLimitMs > 0) {\n                this.inThrottle = true;\n                setTimeout(() => {\n                    this.inThrottle = false;\n                }, eventsPerSecondLimitMs);\n            }\n            return false;\n        };\n    }\n}\n//# sourceMappingURL=RealtimeClient.js.map"]},"metadata":{},"sourceType":"module"}