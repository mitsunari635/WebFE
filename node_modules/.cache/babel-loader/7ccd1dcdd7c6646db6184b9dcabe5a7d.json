{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { resolveFetch } from './helper';\nimport { FunctionsFetchError, FunctionsHttpError, FunctionsRelayError } from './types';\nexport class FunctionsClient {\n  constructor(url, {\n    headers = {},\n    customFetch\n  } = {}) {\n    this.url = url;\n    this.headers = headers;\n    this.fetch = resolveFetch(customFetch);\n  }\n  /**\n   * Updates the authorization header\n   * @param token - the new jwt token sent in the authorisation header\n   */\n\n\n  setAuth(token) {\n    this.headers.Authorization = `Bearer ${token}`;\n  }\n  /**\n   * Invokes a function\n   * @param functionName - The name of the Function to invoke.\n   * @param options - Options for invoking the Function.\n   */\n\n\n  invoke(functionName, options = {}) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          headers,\n          method,\n          body: functionArgs\n        } = options;\n        let _headers = {};\n        let body;\n\n        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type') || !headers)) {\n          if (typeof Blob !== 'undefined' && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n            // will work for File as File inherits Blob\n            // also works for ArrayBuffer as it is the same underlying structure as a Blob\n            _headers['Content-Type'] = 'application/octet-stream';\n            body = functionArgs;\n          } else if (typeof functionArgs === 'string') {\n            // plain string\n            _headers['Content-Type'] = 'text/plain';\n            body = functionArgs;\n          } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n            // don't set content-type headers\n            // Request will automatically add the right boundary value\n            body = functionArgs;\n          } else {\n            // default, assume this is JSON\n            _headers['Content-Type'] = 'application/json';\n            body = JSON.stringify(functionArgs);\n          }\n        }\n\n        const response = yield this.fetch(`${this.url}/${functionName}`, {\n          method: method || 'POST',\n          // headers priority is (high to low):\n          // 1. invoke-level headers\n          // 2. client-level headers\n          // 3. default Content-Type header\n          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n          body\n        }).catch(fetchError => {\n          throw new FunctionsFetchError(fetchError);\n        });\n        const isRelayError = response.headers.get('x-relay-error');\n\n        if (isRelayError && isRelayError === 'true') {\n          throw new FunctionsRelayError(response);\n        }\n\n        if (!response.ok) {\n          throw new FunctionsHttpError(response);\n        }\n\n        let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();\n        let data;\n\n        if (responseType === 'application/json') {\n          data = yield response.json();\n        } else if (responseType === 'application/octet-stream') {\n          data = yield response.blob();\n        } else if (responseType === 'multipart/form-data') {\n          data = yield response.formData();\n        } else {\n          // default to text\n          data = yield response.text();\n        }\n\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        return {\n          data: null,\n          error\n        };\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/FunctionsClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { resolveFetch } from './helper';\nimport { FunctionsFetchError, FunctionsHttpError, FunctionsRelayError, } from './types';\nexport class FunctionsClient {\n    constructor(url, { headers = {}, customFetch, } = {}) {\n        this.url = url;\n        this.headers = headers;\n        this.fetch = resolveFetch(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     */\n    setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     */\n    invoke(functionName, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { headers, method, body: functionArgs } = options;\n                let _headers = {};\n                let body;\n                if (functionArgs &&\n                    ((headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type')) || !headers)) {\n                    if ((typeof Blob !== 'undefined' && functionArgs instanceof Blob) ||\n                        functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers['Content-Type'] = 'application/octet-stream';\n                        body = functionArgs;\n                    }\n                    else if (typeof functionArgs === 'string') {\n                        // plain string\n                        _headers['Content-Type'] = 'text/plain';\n                        body = functionArgs;\n                    }\n                    else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    }\n                    else {\n                        // default, assume this is JSON\n                        _headers['Content-Type'] = 'application/json';\n                        body = JSON.stringify(functionArgs);\n                    }\n                }\n                const response = yield this.fetch(`${this.url}/${functionName}`, {\n                    method: method || 'POST',\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body,\n                }).catch((fetchError) => {\n                    throw new FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get('x-relay-error');\n                if (isRelayError && isRelayError === 'true') {\n                    throw new FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();\n                let data;\n                if (responseType === 'application/json') {\n                    data = yield response.json();\n                }\n                else if (responseType === 'application/octet-stream') {\n                    data = yield response.blob();\n                }\n                else if (responseType === 'multipart/form-data') {\n                    data = yield response.formData();\n                }\n                else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n}\n//# sourceMappingURL=FunctionsClient.js.map"]},"metadata":{},"sourceType":"module"}