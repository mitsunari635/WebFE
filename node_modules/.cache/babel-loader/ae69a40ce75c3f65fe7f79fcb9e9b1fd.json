{"ast":null,"code":"import { DEFAULT_TIMEOUT } from '../lib/constants';\nexport default class Push {\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload;\n    this.timeout = timeout;\n    this.sent = false;\n    this.timeoutTimer = undefined;\n    this.ref = '';\n    this.receivedResp = null;\n    this.recHooks = [];\n    this.refEvent = null;\n    this.rateLimited = false;\n  }\n\n  resend(timeout) {\n    this.timeout = timeout;\n\n    this._cancelRefEvent();\n\n    this.ref = '';\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n    this.send();\n  }\n\n  send() {\n    if (this._hasReceived('timeout')) {\n      return;\n    }\n\n    this.startTimeout();\n    this.sent = true;\n    const status = this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n      join_ref: this.channel._joinRef()\n    });\n\n    if (status === 'rate limited') {\n      this.rateLimited = true;\n    }\n  }\n\n  updatePayload(payload) {\n    this.payload = Object.assign(Object.assign({}, this.payload), payload);\n  }\n\n  receive(status, callback) {\n    var _a;\n\n    if (this._hasReceived(status)) {\n      callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n    }\n\n    this.recHooks.push({\n      status,\n      callback\n    });\n    return this;\n  }\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return;\n    }\n\n    this.ref = this.channel.socket._makeRef();\n    this.refEvent = this.channel._replyEventName(this.ref);\n\n    const callback = payload => {\n      this._cancelRefEvent();\n\n      this._cancelTimeout();\n\n      this.receivedResp = payload;\n\n      this._matchReceive(payload);\n    };\n\n    this.channel._on(this.refEvent, {}, callback);\n\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger('timeout', {});\n    }, this.timeout);\n  }\n\n  trigger(status, response) {\n    if (this.refEvent) this.channel._trigger(this.refEvent, {\n      status,\n      response\n    });\n  }\n\n  destroy() {\n    this._cancelRefEvent();\n\n    this._cancelTimeout();\n  }\n\n  _cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n\n    this.channel._off(this.refEvent, {});\n  }\n\n  _cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = undefined;\n  }\n\n  _matchReceive({\n    status,\n    response\n  }) {\n    this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));\n  }\n\n  _hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n\n}","map":{"version":3,"sources":["../../../src/lib/push.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { DEFAULT_TIMEOUT } from '../lib/constants';\nexport default class Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */\n    constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = '';\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n        this.rateLimited = false;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = '';\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived('timeout')) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        const status = this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef(),\n        });\n        if (status === 'rate limited') {\n            this.rateLimited = true;\n        }\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({ status, callback });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload) => {\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(() => {\n            this.trigger('timeout', {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent)\n            this.channel._trigger(this.refEvent, { status, response });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response, }) {\n        this.recHooks\n            .filter((h) => h.status === status)\n            .forEach((h) => h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n}\n//# sourceMappingURL=push.js.map"]},"metadata":{},"sourceType":"module"}