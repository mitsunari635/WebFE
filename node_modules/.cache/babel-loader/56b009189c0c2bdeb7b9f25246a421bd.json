{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\n\nexport var REALTIME_LISTEN_TYPES;\n\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  /**\n   * listen to Postgres changes.\n   */\n\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\n\nexport var REALTIME_SUBSCRIBE_STATES;\n\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n **/\n\n\nexport default class RealtimeChannel {\n  constructor(\n  /** Topic name can be any string. */\n  topic, params = {\n    config: {}\n  }, socket) {\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: ''\n      }\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n\n      this.socket._remove(this);\n    });\n\n    this._onError(reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return;\n      }\n\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n\n    this.presence = new RealtimePresence(this);\n  }\n  /** Subscribe registers your client with the server */\n\n\n  subscribe(callback, timeout = this.timeout) {\n    var _a, _b;\n\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      const {\n        config: {\n          broadcast,\n          presence\n        }\n      } = this.params;\n\n      this._onError(e => callback && callback('CHANNEL_ERROR', e));\n\n      this._onClose(() => callback && callback('CLOSED'));\n\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : []\n      };\n\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken;\n      }\n\n      this.updateJoinPayload(Object.assign({\n        config\n      }, accessTokenPayload));\n      this.joinedOnce = true;\n\n      this._rejoin(timeout);\n\n      this.joinPush.receive('ok', ({\n        postgres_changes: serverPostgresFilters\n      }) => {\n        var _a;\n\n        this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);\n\n        if (serverPostgresFilters === undefined) {\n          callback && callback('SUBSCRIBED');\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n          const newPostgresBindings = [];\n\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const {\n              filter: {\n                event,\n                schema,\n                table,\n                filter\n              }\n            } = clientPostgresBinding;\n            const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n\n            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                id: serverPostgresFilter.id\n              }));\n            } else {\n              this.unsubscribe();\n              callback && callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n              return;\n            }\n          }\n\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback('SUBSCRIBED');\n          return;\n        }\n      }).receive('error', error => {\n        callback && callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n        return;\n      }).receive('timeout', () => {\n        callback && callback('TIMED_OUT');\n        return;\n      });\n    }\n\n    return this;\n  }\n\n  presenceState() {\n    return this.presence.state;\n  }\n\n  track(payload, opts = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: 'presence',\n        event: 'track',\n        payload\n      }, opts.timeout || this.timeout);\n    });\n  }\n\n  untrack(opts = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: 'presence',\n        event: 'untrack'\n      }, opts);\n    });\n  }\n\n  on(type, filter, callback) {\n    return this._on(type, filter, callback);\n  }\n\n  send(payload, opts = {}) {\n    return new Promise(resolve => {\n      var _a, _b, _c;\n\n      const push = this._push(payload.type, payload, opts.timeout || this.timeout);\n\n      if (push.rateLimited) {\n        resolve('rate limited');\n      }\n\n      if (payload.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n        resolve('ok');\n      }\n\n      push.receive('ok', () => resolve('ok'));\n      push.receive('timeout', () => resolve('timed out'));\n    });\n  }\n\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n\n\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving;\n\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n    };\n\n    this.rejoinTimer.reset(); // Destroy joinPush to avoid connection timeouts during unscription phase\n\n    this.joinPush.destroy();\n    return new Promise(resolve => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', () => {\n        onClose();\n        resolve('ok');\n      }).receive('timeout', () => {\n        onClose();\n        resolve('timed out');\n      }).receive('error', () => {\n        resolve('error');\n      });\n      leavePush.send();\n\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {});\n      }\n    });\n  }\n  /** @internal */\n\n\n  _push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n\n    let pushEvent = new Push(this, event, payload, timeout);\n\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n\n    return pushEvent;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n\n\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /** @internal */\n\n\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  /** @internal */\n\n\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  /** @internal */\n\n\n  _trigger(type, payload, ref) {\n    var _a, _b;\n\n    const typeLower = type.toLocaleLowerCase();\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {\n        var _a, _b, _c;\n\n        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map(bind => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {\n        var _a, _b, _c, _d, _e, _f;\n\n        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n          if ('id' in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map(bind => {\n        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const {\n            schema,\n            table,\n            commit_timestamp,\n            type,\n            errors\n          } = postgresChanges;\n          const enrichedPayload = {\n            schema: schema,\n            table: table,\n            commit_timestamp: commit_timestamp,\n            eventType: type,\n            new: {},\n            old: {},\n            errors: errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  /** @internal */\n\n\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /** @internal */\n\n\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /** @internal */\n\n\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /** @internal */\n\n\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  /** @internal */\n\n\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  /** @internal */\n\n\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback\n    };\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n\n    return this;\n  }\n  /** @internal */\n\n\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {\n      var _a;\n\n      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n    return this;\n  }\n  /** @internal */\n\n\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /** @internal */\n\n\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n\n\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n\n\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n\n\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  /** @internal */\n\n\n  _rejoin(timeout = this.timeout) {\n    if (this._isLeaving()) {\n      return;\n    }\n\n    this.socket._leaveOpenTopic(this.topic);\n\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /** @internal */\n\n\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n\n    return records;\n  }\n\n}","map":{"version":3,"sources":["../../src/RealtimeChannel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    /**\n     * listen to Postgres changes.\n     */\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n **/\nexport default class RealtimeChannel {\n    constructor(\n    /** Topic name can be any string. */\n    topic, params = { config: {} }, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.params.config = Object.assign({\n            broadcast: { ack: false, self: false },\n            presence: { key: '' },\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new RealtimePresence(this);\n    }\n    /** Subscribe registers your client with the server */\n    subscribe(callback, timeout = this.timeout) {\n        var _a, _b;\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        }\n        else {\n            const { config: { broadcast, presence }, } = this.params;\n            this._onError((e) => callback && callback('CHANNEL_ERROR', e));\n            this._onClose(() => callback && callback('CLOSED'));\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence,\n                postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],\n            };\n            if (this.socket.accessToken) {\n                accessTokenPayload.access_token = this.socket.accessToken;\n            }\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush\n                .receive('ok', ({ postgres_changes: serverPostgresFilters, }) => {\n                var _a;\n                this.socket.accessToken &&\n                    this.socket.setAuth(this.socket.accessToken);\n                if (serverPostgresFilters === undefined) {\n                    callback && callback('SUBSCRIBED');\n                    return;\n                }\n                else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for (let i = 0; i < bindingsLen; i++) {\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\n                        const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n                        if (serverPostgresFilter &&\n                            serverPostgresFilter.event === event &&\n                            serverPostgresFilter.schema === schema &&\n                            serverPostgresFilter.table === table &&\n                            serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n                        }\n                        else {\n                            this.unsubscribe();\n                            callback &&\n                                callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback('SUBSCRIBED');\n                    return;\n                }\n            })\n                .receive('error', (error) => {\n                callback &&\n                    callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n                return;\n            })\n                .receive('timeout', () => {\n                callback && callback('TIMED_OUT');\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    track(payload, opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.send({\n                type: 'presence',\n                event: 'track',\n                payload,\n            }, opts.timeout || this.timeout);\n        });\n    }\n    untrack(opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.send({\n                type: 'presence',\n                event: 'untrack',\n            }, opts);\n        });\n    }\n    on(type, filter, callback) {\n        return this._on(type, filter, callback);\n    }\n    send(payload, opts = {}) {\n        return new Promise((resolve) => {\n            var _a, _b, _c;\n            const push = this._push(payload.type, payload, opts.timeout || this.timeout);\n            if (push.rateLimited) {\n                resolve('rate limited');\n            }\n            if (payload.type === 'broadcast' &&\n                !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                resolve('ok');\n            }\n            push.receive('ok', () => resolve('ok'));\n            push.receive('timeout', () => resolve('timed out'));\n        });\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n        };\n        this.rejoinTimer.reset();\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        return new Promise((resolve) => {\n            const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush\n                .receive('ok', () => {\n                onClose();\n                resolve('ok');\n            })\n                .receive('timeout', () => {\n                onClose();\n                resolve('timed out');\n            })\n                .receive('error', () => {\n                resolve('error');\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger('ok', {});\n            }\n        });\n    }\n    /** @internal */\n    _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        }\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n    _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */\n    _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */\n    _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */\n    _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n                var _a, _b, _c;\n                return (((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' ||\n                    ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower);\n            }).map((bind) => bind.callback(handledPayload, ref));\n        }\n        else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n                var _a, _b, _c, _d, _e, _f;\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n                    if ('id' in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return (bindId &&\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\n                            (bindEvent === '*' ||\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) ===\n                                    ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\n                    }\n                    else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return (bindEvent === '*' ||\n                            bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase()));\n                    }\n                }\n                else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind) => {\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors,\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */\n    _isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    /** @internal */\n    _isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    /** @internal */\n    _isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    /** @internal */\n    _isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n    _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */\n    _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback,\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        }\n        else {\n            this.bindings[typeLower] = [binding];\n        }\n        return this;\n    }\n    /** @internal */\n    _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n            var _a;\n            return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\n                RealtimeChannel.isEqual(bind.filter, filter));\n        });\n        return this;\n    }\n    /** @internal */\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n    _onClose(callback) {\n        this._on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n    _onError(callback) {\n        this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n    _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n    _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */\n    _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\n//# sourceMappingURL=RealtimeChannel.js.map"]},"metadata":{},"sourceType":"module"}