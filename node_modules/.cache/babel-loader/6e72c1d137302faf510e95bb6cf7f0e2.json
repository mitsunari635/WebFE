{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}; // @ts-ignore\n\n\nimport nodeFetch, { Headers as NodeFetchHeaders } from '@supabase/node-fetch';\nexport const resolveFetch = customFetch => {\n  let _fetch;\n\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === 'undefined') {\n    _fetch = nodeFetch;\n  } else {\n    _fetch = fetch;\n  }\n\n  return (...args) => _fetch(...args);\n};\nexport const resolveHeadersConstructor = () => {\n  if (typeof Headers === 'undefined') {\n    return NodeFetchHeaders;\n  }\n\n  return Headers;\n};\nexport const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n  const fetch = resolveFetch(customFetch);\n  const HeadersConstructor = resolveHeadersConstructor();\n  return (input, init) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n\n    const accessToken = (_a = yield getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;\n    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n\n    if (!headers.has('apikey')) {\n      headers.set('apikey', supabaseKey);\n    }\n\n    if (!headers.has('Authorization')) {\n      headers.set('Authorization', `Bearer ${accessToken}`);\n    }\n\n    return fetch(input, Object.assign(Object.assign({}, init), {\n      headers\n    }));\n  });\n};","map":{"version":3,"sources":["../../../src/lib/fetch.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA;;;AACA,OAAO,SAAP,IAAoB,OAAO,IAAI,gBAA/B,QAAuD,sBAAvD;AAIA,OAAO,MAAM,YAAY,GAAI,WAAD,IAA+B;AACzD,MAAI,MAAJ;;AACA,MAAI,WAAJ,EAAiB;AACf,IAAA,MAAM,GAAG,WAAT;AACD,GAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,WAArB,EAAkC;AACvC,IAAA,MAAM,GAAG,SAAT;AACD,GAFM,MAEA;AACL,IAAA,MAAM,GAAG,KAAT;AACD;;AACD,SAAO,CAAC,GAAG,IAAJ,KAAa,MAAM,CAAC,GAAG,IAAJ,CAA1B;AACD,CAVM;AAYP,OAAO,MAAM,yBAAyB,GAAG,MAAK;AAC5C,MAAI,OAAO,OAAP,KAAmB,WAAvB,EAAoC;AAClC,WAAO,gBAAP;AACD;;AAED,SAAO,OAAP;AACD,CANM;AAQP,OAAO,MAAM,aAAa,GAAG,CAC3B,WAD2B,EAE3B,cAF2B,EAG3B,WAH2B,KAIlB;AACT,QAAM,KAAK,GAAG,YAAY,CAAC,WAAD,CAA1B;AACA,QAAM,kBAAkB,GAAG,yBAAyB,EAApD;AAEA,SAAO,CAAO,KAAP,EAAc,IAAd,KAAsB,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;;;AAC3B,UAAM,WAAW,GAAG,CAAA,EAAA,GAAC,MAAM,cAAc,EAArB,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,EAAxB,GAA4B,WAAhD;AACA,QAAI,OAAO,GAAG,IAAI,kBAAJ,CAAuB,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,OAA7B,CAAd;;AAEA,QAAI,CAAC,OAAO,CAAC,GAAR,CAAY,QAAZ,CAAL,EAA4B;AAC1B,MAAA,OAAO,CAAC,GAAR,CAAY,QAAZ,EAAsB,WAAtB;AACD;;AAED,QAAI,CAAC,OAAO,CAAC,GAAR,CAAY,eAAZ,CAAL,EAAmC;AACjC,MAAA,OAAO,CAAC,GAAR,CAAY,eAAZ,EAA6B,UAAU,WAAW,EAAlD;AACD;;AAED,WAAO,KAAK,CAAC,KAAD,EAAM,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,IAAP,CAAA,EAAW;AAAE,MAAA;AAAF,KAAX,CAAN,CAAZ;AACD,GAb4B,CAA7B;AAcD,CAtBM","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// @ts-ignore\nimport nodeFetch, { Headers as NodeFetchHeaders } from '@supabase/node-fetch';\nexport const resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = nodeFetch;\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nexport const resolveHeadersConstructor = () => {\n    if (typeof Headers === 'undefined') {\n        return NodeFetchHeaders;\n    }\n    return Headers;\n};\nexport const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n    const fetch = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return (input, init) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        const accessToken = (_a = (yield getAccessToken())) !== null && _a !== void 0 ? _a : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has('apikey')) {\n            headers.set('apikey', supabaseKey);\n        }\n        if (!headers.has('Authorization')) {\n            headers.set('Authorization', `Bearer ${accessToken}`);\n        }\n        return fetch(input, Object.assign(Object.assign({}, init), { headers }));\n    });\n};\n//# sourceMappingURL=fetch.js.map"]},"metadata":{},"sourceType":"module"}